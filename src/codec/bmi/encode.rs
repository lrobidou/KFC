/// Encodes 32 bases in a `u64`.
#[cfg(target_feature = "bmi2")]
#[target_feature(enable = "bmi2")]
unsafe fn encode_32_bases_bmi(bases: &[u8; 32]) -> u64 {
    use std::arch::x86_64::_pext_u64;

    let bytes_0 = u64::from_be_bytes(*(bases.as_ptr() as *const [u8; 8]));
    let bytes_1 = u64::from_be_bytes(*(bases.as_ptr().add(8) as *const [u8; 8]));
    let bytes_2 = u64::from_be_bytes(*(bases.as_ptr().add(16) as *const [u8; 8]));
    let bytes_3 = u64::from_be_bytes(*(bases.as_ptr().add(24) as *const [u8; 8]));

    unsafe {
        let bytes_0 = _pext_u64(bytes_0, 0x0606060606060606);
        let bytes_1 = _pext_u64(bytes_1, 0x0606060606060606);
        let bytes_2 = _pext_u64(bytes_2, 0x0606060606060606);
        let bytes_3 = _pext_u64(bytes_3, 0x0606060606060606);
        (bytes_0 << 48) | (bytes_1 << 32) | (bytes_2 << 16) | bytes_3
    }
}

/// Encodes up to 32 bases in a `u64`.
/// Likely to be slower than `encode_32_bases`, but available on every architectures.
fn encode_up_to_32_bases_slow(bases: &[u8]) -> u64 {
    assert!(bases.len() <= 32);
    let mut result: u64 = 0;
    for base in bases {
        let base_encoded = ((base >> 1) & 3) as u64;
        result = (result << 2) | base_encoded;
    }
    result << ((32 - bases.len()) * 2)
}

/// Encodes up to 32 bases in a `u64`.
/// If the u64 is only partially fulled, bits on the right are set.
/// Likely to be slower than `encode_32_bases`, but available on every architectures.
fn encode_up_to_32_bases_slow_right_aligned(bases: &[u8]) -> u64 {
    assert!(bases.len() <= 32);
    let mut result: u64 = 0;
    for base in bases {
        let base_encoded = ((base >> 1) & 3) as u64;
        result = (result << 2) | base_encoded;
    }
    result
}

pub fn encode_32_bases_all_arch(bases: &[u8; 32]) -> u64 {
    #[cfg(target_feature = "bmi2")]
    // SAFETY: we are behind a cfg, so it should be fine
    let encoded = unsafe { encode_32_bases_bmi(bases) };
    #[cfg(not(target_feature = "bmi2"))]
    let encoded = encode_up_to_32_bases_slow(bases);
    encoded
}

/// Encodes a sequence of ascii characters in `u64`s.
/// Does not takes into account the reverse complement.
pub struct Encoder<'a> {
    bases: &'a [u8],
    current_pos: usize,
}

impl<'a> Encoder<'a> {
    pub fn new(bases: &'a [u8]) -> Self {
        Self {
            bases,
            current_pos: 0,
        }
    }
}

impl Iterator for Encoder<'_> {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current_pos >= self.bases.len() {
            None
        } else if self.current_pos < (self.bases.len() / 32) * 32 {
            let bases = self.bases[self.current_pos..self.current_pos + 32]
                .try_into()
                .unwrap();
            let encoded = encode_32_bases_all_arch(bases);
            self.current_pos += 32;
            Some(encoded)
        } else {
            let rest = encode_up_to_32_bases_slow(&self.bases[self.current_pos..self.bases.len()]);
            self.current_pos = self.bases.len();
            Some(rest)
        }
    }
}

/// Encodes a sequence of ascii characters in `u64`s starting from the end.
/// Usefull when encoding only the suffix might be necessary.
/// Does not takes into account the reverse complement.
pub struct EncoderFromTheEndRightAligned<'a> {
    bases: &'a [u8],
    current_pos: usize,
}

impl<'a> EncoderFromTheEndRightAligned<'a> {
    pub fn new(bases: &'a [u8]) -> Self {
        Self {
            bases,
            current_pos: bases.len(),
        }
    }
}

impl Iterator for EncoderFromTheEndRightAligned<'_> {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current_pos == 0 {
            None
        } else if self.current_pos >= 32 {
            let bases = self.bases[self.current_pos - 32..self.current_pos]
                .try_into()
                .unwrap();
            let encoded = encode_32_bases_all_arch(bases);
            self.current_pos -= 32;
            Some(encoded)
        } else {
            let rest = encode_up_to_32_bases_slow_right_aligned(&self.bases[0..self.current_pos]);
            self.current_pos = 0;
            Some(rest)
        }
    }
}

pub fn encode_32_bases_revcomp(bases: &[u8; 32]) -> u64 {
    let encoded = encode_32_bases_all_arch(bases);
    super::revcomp_32_bases(encoded)
}

// Maps the bits 2 and 3 of the ASCII encoding to the encoding of the revcomp.
// This is to be applied before shifting the ASCII encoding.
const REVCOMP_MAP: [u64; 8] = {
    let mut revcomp_map = [0; 8];
    revcomp_map[0b0000_0000] = 0b0000_0010;
    revcomp_map[0b0000_0100] = 0b0000_0000;
    revcomp_map[0b0000_0010] = 0b0000_0011;
    revcomp_map[0b0000_0110] = 0b0000_0001;
    revcomp_map
};

// Takes up to 32 bases and returns the reverse complement encoded.
// The revcomp is left aligned.
// While this function offers more flexibility than `encode_32_bases_revcomp`,
// which indexes exactly 32 bases,
// `encode_32_bases_revcomp` can be faster depending on you architecture.
pub fn encode_up_to_32_bases_revcomp_slow(bases: &[u8]) -> u64 {
    assert!(bases.len() <= 32);
    let mut result: u64 = 0;
    for base in bases.iter().rev() {
        let base_encoded = (base & 0b0000_0110) as u64;
        let base_encoded_revcomp = REVCOMP_MAP[base_encoded as usize];

        result = (result << 2) | base_encoded_revcomp;
    }
    result << ((32 - bases.len()) * 2)
}

// Takes up to 32 bases and returns the reverse complement encoded.
// The revcomp is rigth aligned.
pub fn encode_up_to_32_bases_revcomp_slow_right_aligned(bases: &[u8]) -> u64 {
    assert!(bases.len() <= 32);
    let mut result: u64 = 0;
    for base in bases.iter().rev() {
        let base_encoded = (base & 0b0000_0110) as u64;
        let base_encoded_revcomp = REVCOMP_MAP[base_encoded as usize];

        result = (result << 2) | base_encoded_revcomp;
    }
    result
}

pub struct RevCompEncoder<'a> {
    bases: &'a [u8],
    nb_u64_full: usize,
    nb_u64_done: usize,
    nb_bases_not_full: usize,
}

impl<'a> RevCompEncoder<'a> {
    pub fn new(bases: &'a [u8]) -> Self {
        Self {
            bases,
            nb_u64_full: bases.len() / 32,
            nb_u64_done: 0,
            nb_bases_not_full: bases.len() % 32,
        }
    }
}

impl Iterator for RevCompEncoder<'_> {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        if self.nb_u64_done < self.nb_u64_full {
            let end = self.bases.len() - self.nb_u64_done * 32;
            let bases = self.bases[end - 32..end].try_into().unwrap();
            let encoded = encode_32_bases_revcomp(bases);
            self.nb_u64_done += 1;
            Some(encoded)
        } else if self.nb_bases_not_full != 0 {
            let rest = encode_up_to_32_bases_revcomp_slow(&self.bases[0..self.nb_bases_not_full]);
            self.nb_bases_not_full = 0;
            Some(rest)
        } else {
            None
        }
    }
}

/// Encodes an ASCII sequence, starting from the suffix (of the reverse complement).
/// Encoded sequence is aligned to the right.
pub struct RevCompEncoderSRA<'a> {
    /// ASCII sequence
    bases: &'a [u8],
    /// current position in the ASCII sequence
    current_pos: usize,
}

impl<'a> RevCompEncoderSRA<'a> {
    pub fn new(bases: &'a [u8]) -> Self {
        Self {
            bases,
            current_pos: 0, // in bases
        }
    }
}

impl Iterator for RevCompEncoderSRA<'_> {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        // end of the reverse = start of the forward
        // so we iterate from the start of the forward
        if self.current_pos >= self.bases.len() {
            None
        } else if self.current_pos + 32 < self.bases.len() {
            // we still have a full u64 available, let's encode it
            let bases = self.bases[self.current_pos..self.current_pos + 32]
                .try_into()
                .unwrap();
            self.current_pos += 32;
            Some(encode_32_bases_revcomp(bases))
        } else {
            // less than 32 bases left
            let rest = encode_up_to_32_bases_revcomp_slow_right_aligned(
                &self.bases[self.current_pos..self.bases.len()],
            );

            self.current_pos = self.bases.len();
            Some(rest)
        }
    }
}

/// Encode bases in a vec. Mainly for tests purposes. Prefer using `Encoder`.
#[cfg(test)]
pub fn encode_bases(bases: &[u8]) -> Vec<u64> {
    let nb_u64 = bases.len() / 32;
    let mut v: Vec<u64> = vec![];
    for i in 0..nb_u64 {
        let bases = bases[i * 32..(i + 1) * 32].try_into().unwrap();
        v.push(encode_32_bases_all_arch(bases));
    }
    if bases.len() % 32 != 0 {
        let rest = encode_up_to_32_bases_slow(&bases[nb_u64 * 32..bases.len()]);
        v.push(rest)
    }
    v
}

#[cfg(test)]
mod tests {
    use itertools::Itertools;

    use crate::codec::{
        bmi::{FusedReverseIterator, RevCompIter},
        prefix::common_prefix_length_fr,
    };

    use super::*;

    // >>> bin(ord('A'))
    // '0b01000001'  # 00 <-> 10 0b10111110 =>
    // >>> bin(ord('C'))
    // '0b01000011'  # 01 <-> 11 0b10111100 =>
    // >>> bin(ord('T'))
    // '0b01010100'  # 10 <-> 00 0b10101011 =>
    // >>> bin(ord('G'))
    // '0b01000111'  # 11 <-> 01 0b10111000 =>

    #[test]
    fn test_encode_32_bases() {
        let read = String::from("TATTTACTGTAATGAAGGACCTTCGTCTCCCC");
        let read = read.as_bytes();
        let encoded = encode_32_bases_all_arch(read.try_into().unwrap());
        assert_eq!(
            encoded,
            //    TATT     TACT     GTAA     TGAA     GGAC     CTTC     GTCT     CCCC
            0b10001010_10000110_11100000_10110000_11110001_01101001_11100110_01010101
        )
    }

    #[test]
    fn test_mutiple_u64() {
        let input: [u64; 5] = [
            0b0001101001000000100000101000100100100010100010101000101010110111,
            0b1000000111111100100010010011000000000011001000101010000101010100,
            0b1010000010101000101000111100101110101000010010011100001010101110,
            0b1100101000001110111011111000101000101010001010001101110000000111,
            0b1010100110011001101011001010101010101000011000000000000000000000,
        ];
        let start = 0;
        let end = 150;
        let fused_reverse = FusedReverseIterator::new(&input, start, end).collect_vec();
        let expected = vec![
            0b1000110111000000011110101001100110011010110010101010101010000110,
            0b1001110000101010111011001010000011101110111110001010001010100010,
            0b0010101000010101010010100000101010001010001111001011101010000100,
            0b1010100010101011011110000001111111001000100100110000000000110010,
            0b0000000000000000000000011010010000001000001010001001001000101000,
        ];

        assert_eq!(fused_reverse, expected);
    }

    #[test]
    fn test_mutiple_u64_start_not_0() {
        let read = [
            0b0000100000101111101111011000010001110100101100110000001011001100,
            0b0011000000001100111111101100100010001011101010110011101010001010,
            0b1111101010101010001010101010110110101010111110111011101000101110,
            0b0110101000100001000000101111101011011011100100111111101110101001,
            0b0110110000100010111100111000011111000000110100000000000000000000,
        ];
        let start = 20;
        let end = 150;
        let fused_reverse = FusedReverseIterator::new(&read, start, end).collect_vec();
        let expected = vec![
            0b0011111110111010100101101100001000101111001110000111110000001101,
            0b1011101110100010111001101010001000010000001011111010110110111001,
            0b1011001110101000101011111010101010100010101010101101101010101111,
            0b0011000000101100110000110000000011001111111011001000100010111010,
            0b0000000000000000000000000000000000000000000000000000000000001011,
        ];

        assert_eq!(fused_reverse, expected);

        let self_read = [
            65, 84, 84, 71, 84, 71, 65, 84, 71, 65, 65, 67, 67, 67, 84, 71, 84, 84, 71, 84, 67, 65,
            71, 67, 65, 67, 67, 84, 67, 71, 71, 71, 84, 65, 71, 71, 67, 65, 71, 84, 84, 67, 71, 67,
            84, 67, 67, 65, 65, 71, 67, 84, 71, 71, 65, 67, 84, 71, 84, 65, 84, 71, 67, 65, 67, 65,
            65, 65, 67, 67, 67, 67, 67, 71, 84, 84, 67, 65, 71, 84, 67, 67, 71, 65, 67, 84, 71, 67,
            84, 71, 67, 71, 67, 67, 84, 84, 65, 67, 67, 67, 71, 71, 84, 65, 65, 67, 84, 65, 84, 67,
            65, 84, 67, 84, 84, 71, 65, 71, 84, 67, 67, 65, 65, 67, 67, 67, 71, 65, 71, 65, 65, 65,
            71, 67, 65, 67, 71, 65, 67, 65, 65, 65, 71, 67, 71, 67, 67, 65, 67, 84, 71, 71, 67, 65,
            71, 67, 65, 71, 67, 67, 65, 67, 84, 71, 71, 84, 65, 65, 67, 84, 71, 71, 71, 65, 84, 65,
            84, 65, 67, 71, 65, 71, 65, 71, 65, 71, 65, 71, 65, 84, 84, 67, 65, 71, 65, 71, 71, 84,
            67, 84, 84, 71, 65, 65, 71, 84, 65, 84, 71, 71, 71, 67, 67, 84, 71, 65, 67, 84, 71, 67,
            71, 71, 67, 84, 65, 67, 65, 67, 84, 71, 65, 65, 65, 71, 65, 65, 67, 65, 71, 84, 84, 84,
            67, 71, 71, 84, 65, 84, 67, 84, 71, 67, 71, 71, 84, 84, 84, 67, 71, 84, 65, 84, 65, 67,
            67, 67, 65, 71, 84, 84, 65, 67, 67, 84, 71, 71, 84, 84, 65, 65, 71, 67, 65, 71, 84, 84,
            67, 67, 67, 67, 65, 65, 67, 84, 71, 65, 67, 84, 84, 65, 65, 67, 67, 84, 84, 67, 71, 65,
            84, 67, 65, 65, 65, 67, 71, 65, 67, 67, 84, 67, 67, 67, 67, 65, 71, 71, 84, 71, 71, 84,
            84, 84, 84, 84, 84, 67, 71, 84, 84, 84, 84, 67, 65, 71, 65, 71, 67, 65, 65, 71, 65, 71,
            65, 84, 84, 65, 67, 71, 65, 67, 84, 71, 65, 65, 65, 67, 71, 65, 67, 65, 71, 71, 65, 84,
            67, 65, 67, 65, 65, 71, 65, 65, 71, 65, 84, 67, 65, 84, 84, 65, 65, 67, 84, 67, 67, 71,
            65, 71, 65, 71, 84, 65, 71, 84, 65, 65, 67, 67, 67, 67, 67, 65, 67, 67, 65, 84, 71, 84,
            84, 84, 71, 67, 67, 84, 65, 84, 67, 65, 65, 67, 65, 67, 65, 67, 84, 84, 65, 71, 71, 65,
            65, 65, 67, 65, 84, 84, 65, 67, 84, 84, 71, 67, 71, 84, 84, 84, 65, 71, 84, 84, 65, 84,
            65, 67, 71, 65, 67, 84, 84, 67, 84, 65, 71, 67, 84, 67, 84, 67, 67, 65, 84, 65, 65, 67,
            65, 71, 65, 84, 67, 67, 84, 67, 65, 84, 84, 84, 84, 67, 84, 71, 67, 84, 71, 65, 84, 71,
            71, 65, 84, 84, 84, 67, 71, 65, 67, 71, 71, 84, 65, 84, 67, 71, 84, 84, 67, 67, 84, 67,
            67, 71, 67, 84, 84, 84, 67, 67, 71, 84, 65, 67, 84, 67, 67, 65, 84, 65, 84, 84, 67, 65,
            71, 71, 65, 65, 65, 67, 65, 67, 67, 67, 84, 71, 65, 67, 65, 71, 67, 65, 65, 67, 67, 65,
            84, 84, 84, 71, 84, 65, 84, 65, 65, 65, 71, 65, 67, 65, 84, 65, 65, 67, 65, 67, 65, 67,
            67, 65, 65, 65, 65, 71, 67, 65, 65, 65, 65, 65, 84, 65, 65, 65, 65, 65, 65, 67, 67, 65,
            65, 84, 65, 65, 65, 67, 84, 67, 65, 65, 65, 67, 65, 84, 65, 84, 65, 84, 67, 65, 67, 67,
            67, 84, 67, 84, 84, 84, 84, 67, 84, 84, 67, 84, 67, 65, 84, 84, 84, 67, 84, 67, 65, 84,
            71, 67, 71, 84, 71, 84, 65, 71, 67, 67, 65, 67, 67, 65, 84, 84, 65, 84, 84, 84, 84, 65,
            84, 65, 71, 84, 84, 65, 71, 67, 65, 67, 84, 67, 71, 84, 65, 71, 71, 71, 84, 84, 67, 84,
            67, 67, 65, 84, 65, 84, 65, 84, 84, 84, 65, 67, 71, 71, 71, 84, 65, 71, 67, 65, 67, 71,
            84, 84, 67, 71, 65, 67, 71, 71, 67, 65, 71, 65, 84, 84, 67, 71, 71, 65, 84, 71, 65, 65,
            67, 84, 65, 65, 65, 65, 65, 65, 65, 65, 71, 67, 65, 84, 65, 65, 65, 84, 65, 65, 84, 84,
            84, 65, 65, 65, 84, 71, 67, 65, 65, 84, 65, 65, 67, 71, 71, 67, 71, 65, 67, 84, 65, 67,
            67, 65, 67, 84, 65, 67, 65, 67, 67, 65, 65, 84, 65, 65, 65, 84, 71, 84, 65, 65, 71, 67,
            65, 84, 67, 65, 67, 65, 71, 71, 84, 71, 67, 84, 71, 65, 67, 65, 65, 67, 65, 71, 71, 71,
            84, 84, 67, 65, 84, 67, 65, 67, 65,
        ];

        let size_prefix = common_prefix_length_fr(&self_read[529..549], &read, start, end);
        let common_prefix = std::cmp::min(size_prefix, 20);
        assert_eq!(common_prefix, 20);
    }

    #[test]
    fn test_mutiple_u64_start_not_0_2() {
        let read = [
            0b1100001100110111010110100010111011000100101010100110010110100001,
            0b1101100101100110001011010111101001101101001001011011100101111100,
            0b1011011110100010001001010111111000001100101010100101110110100100,
            0b0000110111101110011011100010110110111010011011110011101001101001,
            0b1011011100111010011110110100111010100110010000000000000000000000,
        ];
        let start = 26;
        let end = 150;
        let fused_reverse = FusedReverseIterator::new(&read, start, end).collect_vec();
        let expected = vec![
            0b1111001110100110100110110111001110100111101101001110101001100100,
            0b1010010111011010010000001101111011100110111000101101101110100110,
            0b0101101110010111110010110111101000100010010101111110000011001010,
            0b0000000001011010000111011001011001100010110101111010011011010010,
        ];

        assert_eq!(fused_reverse, expected);

        let self_read = [
            71, 67, 65, 71, 67, 65, 71, 67, 65, 65, 71, 67, 67, 71, 84, 65, 67, 84, 67, 65, 65, 67,
            65, 84, 71, 71, 67, 71, 71, 71, 65, 84, 84, 67, 65, 84, 65, 65, 65, 65, 65, 71, 84, 67,
            65, 71, 65, 71, 67, 67, 84, 71, 65, 67, 71, 67, 84, 71, 67, 84, 67, 71, 65, 65, 65, 65,
            65, 67, 84, 71, 71, 65, 67, 71, 67, 65, 67, 84, 67, 65, 65, 84, 71, 67, 67, 71, 65, 67,
            71, 65, 65, 67, 65, 71, 71, 67, 67, 71, 67, 67, 65, 84, 71, 84, 71, 84, 71, 65, 71, 65,
            65, 65, 67, 84, 71, 67, 65, 67, 71, 65, 65, 67, 84, 67, 71, 67, 65, 71, 65, 65, 71, 65,
            65, 67, 84, 67, 67, 65, 71, 65, 65, 67, 65, 71, 67, 65, 84, 65, 67, 65, 71, 65, 67, 65,
            67, 71, 67, 84, 84, 84, 71, 65, 65, 71, 67, 71, 71, 65, 65, 65, 65, 84, 67, 84, 84, 65,
            67, 67, 71, 71, 71, 65, 84, 65, 84, 65, 65, 67, 71, 67, 65, 84, 67, 67, 71, 71, 65, 67,
            65, 71, 71, 65, 84, 71, 67, 65, 71, 65, 65, 67, 71, 71, 67, 65, 84, 65, 71, 65, 71, 71,
            65, 71, 67, 71, 84, 65, 65, 71, 71, 65, 71, 65, 65, 65, 65, 84, 71, 84, 67, 65, 67, 65,
            84, 65, 65, 71, 71, 67, 71, 67, 84, 67, 84, 84, 67, 67, 71, 67, 84, 84, 67, 67, 84, 67,
            71, 67, 84, 67, 65, 67, 84, 71, 65, 67, 84, 67, 71, 67, 84, 65, 67, 71, 67, 84, 67, 71,
            71, 84, 67, 71, 84, 84, 67, 71, 65, 67, 84, 71, 67, 71, 71, 67, 71, 65, 71, 67, 71, 71,
            84, 71, 84, 67, 65, 71, 67, 84, 67, 65, 67, 84, 67, 65, 65, 65, 71, 71, 67, 71, 71, 84,
            65, 65, 84, 65, 67, 71, 71, 84, 84, 65, 84, 67, 67, 65, 67, 65, 71, 65, 65, 84, 67, 71,
            71, 71, 71, 71, 65, 84, 65, 65, 65, 65, 67, 67, 71, 71, 65, 65, 65, 71, 65, 65, 67, 65,
            84, 71, 84, 71, 65, 71, 67, 65, 65, 65, 65, 71, 65, 67, 65, 65, 65, 71, 65, 67, 67, 67,
            65, 71, 65, 65, 71, 65, 65, 71, 71, 71, 67, 71, 67, 71, 67, 71, 71, 71, 65, 71, 71, 67,
            71, 84, 84, 84, 84, 84, 67, 67, 65, 84, 65, 71, 71, 67, 84, 67, 67, 71, 67, 67, 67, 67,
            67, 67, 67, 84, 71, 65, 67, 71, 65, 71, 67, 65, 84, 67, 65, 67, 65, 65, 65, 65, 65, 84,
            67, 71, 65, 67, 71, 67, 84, 67, 65, 65, 71, 84, 67, 65, 71, 65, 71, 71, 84, 71, 71, 67,
            71, 65, 65, 65, 67, 67, 67, 71, 65, 67, 65, 71, 71, 65, 67, 84, 65, 84, 65, 65, 65, 71,
            65, 84, 65, 67, 67, 65, 71, 71, 67, 71, 84, 84, 84, 67, 67, 67, 67, 67, 84, 71, 71, 65,
            65, 71, 67, 84, 67, 67, 67, 84, 67, 71, 84, 71, 67, 71, 67, 84, 67, 84, 67, 67, 84, 71,
            84, 84, 67, 67, 71, 65, 67, 67, 67, 84, 71, 67, 67, 71, 67, 84, 84, 65, 67, 67, 71, 71,
            65, 84, 65, 67, 67, 84, 71, 84, 67, 67, 71, 67, 67, 84, 84, 84, 67, 84, 67, 67, 67, 84,
            84, 67, 71, 71, 71, 65, 65, 71, 67, 71, 84, 71, 71, 67, 71, 67, 84, 84, 84, 67, 84, 67,
            65, 84, 65, 71, 67, 84, 67, 65, 67, 71, 67, 84, 71, 84, 84, 71, 71, 84, 65, 84, 67, 84,
            67, 71, 71, 84, 84, 67, 71, 71, 84, 71, 84, 65, 71, 71, 84, 67, 71, 84, 84, 67, 71, 67,
            84, 67, 67, 65, 65, 71, 67, 84, 71, 71, 71, 67, 84, 71, 84, 71, 84, 71, 67, 65, 67, 71,
            65, 65, 67, 67, 67, 67, 67, 67, 71, 84, 84, 67, 65, 71, 67, 67, 67, 71, 65, 67, 67, 71,
            67, 84, 71, 67, 71, 67, 67, 84, 84, 65, 84, 67, 67, 71, 71, 84, 65, 65, 67, 84, 65, 84,
            67, 71, 84, 67, 84, 84, 71, 65, 71, 84, 67, 67, 65, 65, 67, 67, 67, 71, 71, 84, 65, 65,
            71, 65, 67, 65, 67, 71, 65, 67, 84, 84, 65, 65, 67, 71, 67, 67, 65, 67, 84, 71, 71, 67,
            65, 65, 67, 71, 71, 67, 67, 65, 67, 84, 71, 71, 84, 65, 65, 71, 67, 65, 71, 71, 65, 84,
            71, 84, 71, 67, 71, 65, 71, 65, 71, 65, 84, 71, 84, 65, 65, 67, 71, 65, 71, 65, 71, 84,
            84, 67, 84, 84, 71, 65, 65, 71, 84, 71, 71, 67, 71, 71, 67, 67, 84, 65, 65, 67, 84, 71,
            65, 71, 71, 67, 84, 65, 67, 65, 67, 84, 71, 65, 65, 65, 71, 71, 65, 67, 65, 71, 84, 65,
            84, 84, 84, 71, 71, 84, 71, 65, 67, 65, 84, 71, 84, 67, 84, 67, 71, 67, 65, 67, 65, 65,
            71, 65, 67, 84, 71, 84, 84, 65, 67, 67, 65, 67, 71, 71, 84, 84, 65, 71, 65, 71, 65, 65,
            84, 67, 84, 71, 67, 67, 65, 71, 71, 65, 84, 84, 65, 65, 67, 84, 65, 65, 67, 67, 84, 84,
            67, 71, 65, 65, 65, 65, 65, 67, 67, 65, 67, 67, 84, 71, 67, 67, 65, 71, 71, 71, 84, 71,
            71, 84, 84, 84, 84, 84, 84, 67, 71, 84, 84, 84, 84, 84, 65, 67, 65, 65, 84, 65, 71, 84,
            71, 65, 71, 65, 84, 84, 65, 67, 71, 65, 67, 71, 65, 71, 65, 67, 84, 71, 65, 65, 84, 71,
            65, 65, 84, 67, 84, 67, 65, 65, 71, 65, 84, 84, 84, 67, 65, 84, 84, 84, 65, 71, 67, 67,
            84, 71, 67, 67, 71, 67, 84, 67, 71, 65, 84, 67, 65, 84, 84, 67, 65, 65, 65, 71, 84, 84,
            84, 84, 71, 65, 71, 71, 84, 65, 71, 67, 84, 84, 67, 65, 84, 84, 71, 71, 71, 84, 67, 65,
            84, 71, 71, 84, 65, 84, 67, 67, 65, 65, 71, 67, 84, 67, 84, 65, 65, 65, 65, 71, 67, 84,
            84, 84, 65, 84, 65, 84, 71, 71, 84, 84, 67, 71, 71, 84, 71, 84, 67, 65, 71, 67, 67, 71,
            67, 84, 71, 71, 65, 65, 65, 84, 71, 65, 65, 84, 65, 65, 67, 67, 67, 65, 71, 84, 67, 65,
            71, 65, 65, 65, 67, 67, 84, 84, 71, 84, 65, 84, 84, 84, 67, 67, 67, 65, 84, 71, 65, 65,
            65, 67, 71, 84, 65, 84, 67, 84, 84, 84, 65, 65, 65, 65, 65, 67, 67, 71, 71, 65, 84, 67,
            71, 67, 67, 84, 65, 65, 65, 84, 71, 65, 71, 67, 65, 84, 71, 67, 67, 65, 84, 65, 65, 84,
            84, 84, 71, 84, 84, 65, 71, 67, 84, 67, 84, 65, 71, 67, 65, 84, 65, 67, 84, 84, 67, 84,
            67, 65, 65, 84, 65, 71, 67, 84, 84, 67, 84, 84, 84, 71, 84, 84, 84, 84, 67, 71, 84, 65,
            65, 84, 71, 65, 84, 67, 65, 71, 71, 67, 65, 67, 84, 84, 84, 67, 67, 65, 67, 71, 65, 84,
            71, 71, 67, 71, 65, 84, 65, 67, 84, 84, 84, 71, 67, 67, 65, 71, 84, 67, 67, 65, 65, 71,
            67, 84, 71, 71, 65, 84, 65, 84, 67, 67, 84, 84, 84, 84, 65, 65, 65, 71, 71, 65, 84, 67,
            71, 67, 67, 65, 65, 65, 71, 65, 71, 65, 84, 84, 71, 84, 65, 84, 84, 84, 84, 84, 67, 65,
            65, 65, 65, 84, 71, 67, 84, 67, 65, 65, 84, 71, 65, 65, 65, 84, 67, 65, 84, 67, 71, 65,
            84, 84, 84, 84, 65, 84, 67, 71, 65, 71, 84, 71, 84, 84, 84, 84, 84, 71, 67, 65, 71, 65,
            65, 84, 65, 84, 67, 84, 71, 71, 65, 84, 71, 84, 71, 84, 65, 65, 84, 65, 65, 65, 71, 71,
            84, 84, 71, 65, 65, 71, 71, 84, 67, 84, 67, 65, 71, 65, 71, 65, 65, 84, 71, 65, 71, 65,
            67, 65, 65, 84, 65, 84, 84, 67, 65, 65, 84, 84, 71, 84, 71, 71, 65, 84, 84, 84, 84, 71,
            67, 71, 67, 71, 67, 67, 84, 71, 67, 84, 67, 67, 71, 67, 84, 71, 67, 67, 67, 65, 84, 71,
            67, 84, 67, 84, 84, 67, 84, 67, 84, 71, 67, 84, 67, 67, 67, 71, 65, 67, 84, 84, 65, 71,
            65, 67, 67, 65, 71, 65, 84, 71, 71, 67, 65, 84, 84, 71, 84, 65, 65, 67, 65, 71, 65, 67,
            84, 84, 67, 84, 67, 65, 84, 84, 67, 71, 67, 84, 67, 84, 71, 71, 65, 65, 65, 84, 67, 65,
            65, 67, 65, 71, 65, 71, 65, 67, 65, 65, 71, 71, 65, 84, 65, 67, 71, 67, 67, 65, 65, 65,
            65, 65, 67, 67, 84, 67, 65, 65, 84, 65, 84, 67, 84, 84, 84, 65, 65, 67, 65, 65, 71, 65,
            84, 67, 65, 84, 71, 65, 67, 71, 84, 84, 71, 84, 84, 67, 71, 71, 84, 84, 84, 84, 67, 65,
            84, 65, 84, 67, 71, 67, 84, 65, 65, 67, 84, 67, 67, 71, 84, 65, 84, 67, 84, 65, 65, 84,
            84, 67, 65, 71, 71, 67, 65, 71, 71, 65, 65, 65, 65, 65, 65, 84, 67, 84, 84, 84, 84, 67,
            67, 84, 67, 71, 84, 84, 84, 84, 67, 65, 71, 65, 71, 84, 65, 71, 84, 67, 84, 84, 84, 84,
            84, 84, 71, 71, 84, 84, 71, 67, 65, 67, 65, 65, 84, 65, 65, 84, 71, 71, 67, 71, 67, 67,
            65, 71, 84, 71, 84, 67, 65, 67, 67, 67, 84, 65, 84, 84, 67, 65, 84, 65, 84, 71, 65, 65,
            84, 65, 84, 65, 67, 67, 65, 84, 65, 84, 65, 65, 84, 65, 84, 65, 84, 65, 67, 84, 84, 84,
            65, 65, 65, 84, 65, 84, 84, 84, 84, 71, 71, 71, 71, 67, 84, 84, 65, 71, 71, 65, 65, 65,
            65, 84, 67, 65, 65, 84, 71, 65, 67, 84, 84, 65, 67, 84, 67, 67, 71, 84, 84, 65, 65, 71,
            65, 65, 84, 65, 65, 65, 84, 71, 71, 65, 65, 65, 71, 67, 84, 71, 71, 67, 71, 71, 84, 84,
            84, 71, 84, 67, 84, 67, 84, 84, 71, 71, 67, 84, 71, 71, 65, 67, 65, 71, 67, 65, 71, 84,
            71, 67, 67, 84, 65, 67, 67, 71, 84, 65, 84, 84, 71, 84, 84, 84, 84, 84, 84, 65, 84, 65,
            67, 65, 65, 65, 65, 67, 71, 65, 71, 65, 65, 65, 65, 65, 71, 67, 84, 65, 65, 67, 84, 84,
            67, 65, 71, 84, 71, 71, 67, 67, 84, 84, 84, 65, 65, 67, 65, 67, 65, 67, 84, 65, 67, 84,
            84, 65, 65, 67, 67, 84, 71, 65, 84, 67, 71, 84, 84, 67, 65, 67, 84, 71, 71, 84, 71, 71,
            65, 71, 84, 84, 84, 71, 67, 65, 65, 71, 65, 71, 84, 71, 71, 67, 67, 71, 67, 65, 84, 67,
            67, 71, 84, 67, 65, 65, 84, 71, 71, 65, 65, 65, 71, 84, 67, 84, 65, 71, 67, 67, 65, 84,
            65, 67, 71, 84, 65, 84, 71, 71, 71, 71, 71, 84, 84, 84, 67, 84, 71, 84, 65, 67, 71, 71,
            65, 67, 84, 71, 84, 84, 67, 65, 71, 65, 71, 65, 71, 67, 84, 65, 84, 67, 65, 65, 84, 71,
            65, 84, 67, 84, 84, 71, 65, 65, 65, 65, 65, 71, 67, 84, 65, 65, 84, 67, 84, 67, 84, 84,
            71, 71, 65, 67, 65, 65, 71, 65, 65, 65, 67, 67, 65, 65, 67, 65, 84, 67, 71, 65, 65, 71,
            65, 71, 84, 71, 65, 84, 67, 71, 67, 67, 71, 65, 84, 65, 84, 71, 71, 84, 71, 71, 84, 67,
            71, 67, 65, 65, 84, 65, 84, 84, 84, 65, 84, 71, 65, 84, 67, 84, 65, 65, 67, 65, 65, 65,
            71, 67, 84, 65, 71, 84, 84, 71, 65, 67, 84, 65, 67, 67, 84, 65, 71, 65, 84, 65, 67, 65,
            65, 84, 71, 71, 71, 84, 67, 67, 65, 84, 67, 65, 71, 84, 65, 71, 67, 84, 71, 65, 65, 67,
            65, 65, 71, 84, 84, 65, 65, 71, 65, 65, 65, 67, 67, 65, 67, 71, 67, 67, 65, 84, 65, 65,
            65, 65, 65, 65, 67, 67, 71, 71, 84, 65, 84, 65, 84, 65, 67, 67, 71, 84, 65, 65, 71, 65,
            65, 65, 65, 65, 67, 71, 65, 67, 65, 71, 67, 84, 84, 65, 65, 65, 65, 65, 65, 71, 67, 65,
            67, 65, 65, 84, 71, 71, 65, 65, 67, 84, 71, 65, 65, 71, 67, 71, 65, 71, 67, 71, 65, 84,
            71, 67, 65, 67, 71, 65, 84, 65, 71, 67, 65, 65, 65, 65, 67, 71, 65, 84, 65, 84, 65, 84,
            84, 65, 67, 84, 84, 65, 84, 84, 71, 67, 65, 84, 84, 71, 71, 84, 67, 84, 84, 71, 71, 84,
            65, 71, 67, 67, 67, 84, 71, 67, 84, 84, 67, 84, 71, 71, 67, 84, 65, 65, 65, 67, 67, 65,
            67, 84, 71, 84, 67, 65, 71, 71, 65, 71, 84, 65, 65, 84, 84, 71, 71, 67, 84, 84, 84, 71,
            67, 67, 84, 71, 84, 65, 65, 84, 71, 71, 71, 84, 84, 67, 65, 84, 67, 71, 67, 84, 84, 67,
            65, 67, 65, 71, 84, 84, 65, 65, 65, 71, 84, 84, 65, 84, 67, 71, 67, 65, 84, 65, 71, 67,
            84, 67, 65, 84, 65, 84, 65, 84, 84, 84, 65, 67, 67, 65, 84, 65, 65, 84, 67, 67, 67, 84,
            84, 65, 65, 84, 84, 71, 84, 65, 67, 71, 67, 65, 67, 67, 65, 67, 84, 71, 65, 65, 65, 67,
            71, 67, 71, 67, 84, 71, 65, 65, 67, 71, 67, 71, 65, 84, 84, 67, 84, 71, 65, 67, 71, 67,
            65, 71, 65, 67, 65, 67, 67, 71, 67, 65, 65, 65, 65, 65, 71, 65, 71, 65, 84, 71, 84, 84,
            84, 84, 65, 67, 67, 67, 67, 71, 71, 65, 65, 65, 65, 65, 67, 65, 71, 71, 65, 65, 71, 71,
            65, 84, 71, 67, 71, 84, 67, 65, 71, 71, 65, 84, 67, 71, 84, 84, 84, 84, 67, 65, 71, 67,
            84, 67, 71, 67, 84, 71, 67, 65, 84, 65, 71, 67, 84, 65, 84, 71, 67, 65, 84, 71, 65, 65,
            65, 71, 67, 71, 65, 65, 84, 71, 71, 84, 71, 65, 84, 67, 65, 67, 84, 84, 84, 71, 71, 71,
            65, 71, 67, 84, 84, 65, 67, 71, 71, 84, 71, 84, 84, 67, 65, 84, 65, 67, 67, 71, 84, 67,
            65, 71, 84, 84, 84, 84, 67, 71, 65, 67, 65, 71, 84, 84, 84, 84, 67, 84, 67, 84, 67, 67,
            71, 71, 71, 65, 65, 71, 67, 84, 65, 65, 84, 67, 84, 71, 67, 67, 65, 84, 65, 65, 71, 67,
            67, 84, 71, 71, 65, 84, 65, 65, 67, 65, 71, 71, 71, 67, 65, 67, 71, 71, 84, 71, 65, 84,
            65, 67, 84, 67, 67, 71, 84, 65, 65, 84, 65, 71, 67, 71, 65, 84, 67, 65, 71, 67, 65, 67,
            67, 84, 67, 67, 71, 67, 65, 84, 65, 67, 84, 67, 67, 67, 84, 71, 84, 67, 67, 67, 67, 71,
            65, 67, 65, 67, 71, 67, 84, 84, 71, 67, 67, 71, 84, 67, 71, 65, 84, 65, 65, 65, 71, 65,
            71, 84, 84, 84, 84, 84, 84, 67, 84, 71, 84, 65, 65, 67, 71, 67, 67, 67, 67, 67, 65, 71,
            84, 67, 84, 67, 65, 84, 65, 65, 67, 84, 84, 67, 84, 84, 84, 67, 65, 71, 84, 65, 67, 67,
            67, 71, 65, 84, 67, 65, 84, 67, 65, 71, 84, 67, 65, 71, 84, 71, 65, 71, 84, 84, 65, 65,
            67, 84, 84, 84, 67, 84, 84, 65, 67, 67, 71, 65, 71, 65, 71, 67, 84, 71, 67, 67, 71, 67,
            67, 67, 71, 84, 65, 65, 65, 65, 65, 65, 67, 67, 71, 71, 65, 65, 65, 67, 71, 71, 84, 67,
            84, 84, 71, 67, 67, 71, 67, 65, 84, 84, 67, 65, 71, 67, 65, 71, 67, 67, 67, 84, 84, 84,
            84, 84, 67, 84, 71, 65, 84, 84, 84, 67, 67, 84, 71, 71, 84, 67, 84, 84, 67, 84, 84, 67,
            84, 71, 67, 67, 71, 84, 67, 65, 71, 65, 67, 71, 65, 65, 67, 65, 71, 71, 71, 67, 71, 65,
            67, 84, 71, 65, 84, 65, 71, 67, 67, 67, 71, 67, 67, 84, 71, 67, 71, 67, 71, 84, 65, 84,
            84, 65, 67, 84, 84, 67, 67, 65, 67, 84, 84, 67, 71, 84, 84, 84, 84, 71, 84, 67, 65, 84,
            65, 65, 65, 65, 67, 65, 84, 71, 71, 67, 84, 67, 67, 71, 84, 65, 84, 67, 84, 71, 65, 67,
            65, 84, 71, 71, 71, 84, 71, 84, 67, 71, 71, 71, 71, 67, 65, 65, 65, 71, 67, 67, 67, 84,
            71, 65, 67, 67, 65, 71, 71, 71, 67, 65, 65, 84, 84, 71, 84, 65, 65, 84, 65, 71, 67, 71,
            84, 71, 67, 65, 84, 71, 84, 65, 84, 71, 67, 71, 67, 71, 71, 84, 65, 84, 65, 65, 67, 65,
            65, 84, 84, 71, 67, 65, 67, 65, 84, 67, 67, 84, 71, 84, 67, 67, 84, 71, 84, 67, 65, 71,
            67, 65, 65, 71, 67, 84, 67, 71, 65, 65, 84, 84, 65, 67, 67, 71, 65, 67, 65, 65, 65, 71,
            71, 67, 65, 67, 71, 71, 67, 65, 71, 84, 84, 84, 84, 84, 84, 71, 71, 67, 65, 71, 84, 71,
            65,
        ];
        let start_self = 105;
        let end_self = 229;

        let encode_self = Encoder::new(&self_read[start_self..end_self]).collect_vec();

        let revcomp_other = RevCompIter::new(&read, start, end).collect_vec();
        assert_eq!(encode_self[0], revcomp_other[0]); // 32 bases: OK
        assert_eq!(encode_self[1], revcomp_other[1]); // 64 bases: OK
        assert_eq!(encode_self[2], revcomp_other[2]); // 96 bases: OK

        let size_prefix =
            common_prefix_length_fr(&self_read[start_self..end_self], &read, start, end);
        assert_eq!(size_prefix, 124);
    }

    #[test]
    fn test_mutiple_u64_start_not_0_3() {
        let read = [
            0b0010000111110011101000110111001000101100000000010111000001000001,
            0b1110010010110010011010111010000000110010001010110011111010101010,
            0b1111011110001001011010111001100110111010110010101001010011001101,
            0b1100001011001100001110011011101000010000101101010010011011111001,
            0b1000001110011111110011010011001100001100110100000000000000000000,
        ];
        let start = 0;
        let end = 43;
        let fused_reverse = FusedReverseIterator::new(&read, start, end).collect_vec();
        let expected = vec![
            0b1101110010001011000000000101110000010000011110010010110010011010,
            0b0000000000000000000000000000000000000000000010000111110011101000,
            // 0b0110111010000100001011010100100110111110011000001110011111110011,
        ];

        assert_eq!(fused_reverse, expected);

        let self_read = [
            84, 71, 84, 67, 65, 71, 67, 65, 67, 67, 84, 71, 84, 65, 67, 65, 71, 67, 84, 84, 67, 65,
            84, 84, 71, 71, 71, 84, 67, 65, 84, 71, 71, 84, 65, 84, 67, 67, 65, 65, 71, 67, 84, 67,
            84, 65, 65, 65, 65, 71, 67, 84, 84, 84, 65, 84, 65, 84, 71, 71, 84, 84, 67, 71, 71, 84,
            71, 84, 67, 65, 71, 67, 67, 71, 67, 84, 71, 71, 65, 65, 65, 84, 71, 65, 65, 84, 65, 65,
            67, 67, 67, 65, 71, 84, 67, 65, 71, 65, 65, 65, 67, 67, 84, 84, 71, 84, 65, 84, 84, 84,
            67, 67, 67, 65, 84, 71, 65, 65, 65, 67, 71, 84, 65, 84, 67, 84, 84, 84, 65, 65, 65, 65,
            65, 67, 67, 71, 71, 65, 84, 67, 71, 67, 67, 84, 65, 65, 65, 84, 71, 65, 71, 67, 65, 84,
            71, 67, 67, 65, 84, 65, 65, 84, 84, 84, 71, 84, 84, 65, 71, 67, 84, 67, 84, 65, 71, 67,
            65, 84, 65, 67, 84, 84, 67, 84, 67, 65, 65, 84, 65, 71, 67, 84, 84, 67, 84, 84, 84, 71,
            84, 84, 84, 84, 67, 71, 84, 65, 65, 84, 71, 65, 84, 67, 65, 71, 71, 67, 65, 67, 84, 84,
            84, 67, 67, 65, 67, 71, 65, 84, 71, 71, 67, 71, 65, 84, 65, 67, 84, 84, 84, 71, 67, 67,
            65, 71, 84, 67, 67, 65, 65, 71, 67, 84, 71, 71, 65, 84, 65, 84, 67, 67, 84, 84, 84, 84,
            65, 65, 65, 71, 71, 65, 84, 67, 71, 67, 67, 65, 65, 65, 71, 65, 71, 65, 84, 84, 71, 84,
            65, 84, 84, 84, 84, 84, 67, 65, 65, 65, 65, 84, 71, 67, 84, 67, 65, 65, 84, 71, 65, 65,
            65, 84, 67, 65, 84, 67, 71, 65, 84, 84, 84, 84, 65, 84, 67, 71, 65, 71, 84, 71, 84, 84,
            84, 84, 84, 71, 67, 65, 71, 65, 65, 84, 65, 84, 67, 84, 71, 71, 65, 84, 71, 84, 71, 84,
            65, 65, 84, 65, 65, 65, 71, 71, 84, 84, 71, 65, 65, 71, 71, 84, 67, 84, 67, 65, 71, 65,
            71, 65, 65, 84, 71, 65, 71, 65, 67, 65, 65, 84, 65, 84, 84, 67, 65, 65, 84, 84, 71, 84,
            71, 71, 65, 84, 84, 84, 84, 71, 67, 71, 67, 71, 67, 67, 84, 71, 67, 84, 67, 67, 71, 67,
            84, 71, 67, 67, 67, 65, 84, 71, 67, 84, 67, 84, 84, 67, 84, 67, 84, 71, 67, 84, 67, 67,
            67, 71, 65, 67, 84, 84, 65, 71, 65, 67, 67, 65, 71, 65, 84, 71, 71, 67, 65, 84, 84, 71,
            84, 65, 65, 67, 65, 71, 65, 67, 84, 84, 67, 84, 67, 65, 84, 84, 67, 71, 67, 84, 67, 84,
            71, 71, 65, 65, 65, 84, 67, 65, 65, 67, 65, 71, 65, 71, 65, 67, 65, 65, 71, 71, 65, 84,
            65, 67, 71, 67, 67, 65, 65, 65, 65, 65, 67, 67, 84, 67, 65, 65, 84, 65, 84, 67, 84, 84,
            84, 65, 65, 67, 65, 65, 71, 65, 84, 67, 65, 84, 71, 65, 67, 71, 84, 84, 71, 84, 84, 67,
            71, 71, 84, 84, 84, 84, 67, 65, 84, 65, 84, 67, 71, 67, 84, 65, 65, 67, 84, 67, 67, 71,
            84, 65, 84, 67, 84, 65, 65, 84, 84, 67, 65, 71, 71, 67, 65, 71, 71, 65, 65, 65, 65, 65,
            65, 84, 67, 84, 84, 84, 84, 67, 67, 84, 67, 71, 84, 84, 84, 84, 67, 65, 71, 65, 71, 84,
            65, 71, 84, 67, 84, 84, 84, 84, 84, 84, 71, 71, 84, 84, 71, 67, 65, 67, 65, 65, 84, 65,
            65, 84, 71, 71, 67, 71, 67, 67, 65, 71, 84, 71, 84, 67, 65, 67, 67, 67, 84, 65, 84, 84,
            67, 65, 84, 65, 84, 71, 65, 65, 84, 65, 84, 65, 67, 67, 65, 84, 65, 84, 65, 65, 84, 65,
            84, 65, 84, 65, 67, 84, 84, 84, 65, 65, 65, 84, 65, 84, 84, 84, 84, 71, 71, 71, 71, 67,
            84, 84, 65, 71, 71, 65, 65, 65, 65, 84, 67, 65, 65, 84, 71, 65, 67, 84, 84, 65, 67, 84,
            67, 67, 71, 84, 84, 65, 65, 71, 65, 65, 84, 65, 65, 65, 84, 71, 71, 65, 65, 65, 71, 67,
            84, 71, 71, 67, 71, 71, 84, 84, 84, 71, 84, 67, 84, 67, 84, 84, 71, 71, 67, 84, 71, 71,
            65, 67, 65, 71, 67, 65, 71, 84, 71, 67, 67, 84, 65, 67, 67, 71, 84, 65, 84, 84, 71, 84,
            84, 84, 84, 84, 84, 65, 84, 65, 67, 65, 65, 65, 65, 67, 71, 65, 71, 65, 65, 65, 65, 65,
            71, 67, 84, 65, 65, 67, 84, 84, 67, 65, 71, 84, 71, 71, 67, 67, 84, 84, 84, 65, 65, 67,
            65, 67, 65, 67, 84, 65, 67, 84, 84, 65, 65, 67, 67, 84, 71, 65, 84, 67, 71, 84, 84, 67,
            65, 67, 84, 71, 71, 84, 71, 71, 65, 71, 84, 84, 84, 71, 67, 65, 65, 71, 65, 71, 84, 71,
            71, 67, 67, 71, 67, 65, 84, 67, 67, 71, 84, 67, 65, 65, 84, 71, 71, 65, 65, 65, 71, 84,
            67, 84, 65, 71, 67, 67, 65, 84, 65, 67, 71, 84, 65, 84, 71, 71, 71, 71, 71, 84, 84, 84,
            67, 84, 71, 84, 65, 67, 71, 71, 65, 67, 84, 71, 84, 84, 67, 65, 71, 65, 71, 65, 71, 67,
            84, 65, 84, 67, 65, 65, 84, 71, 65, 84, 67, 84, 84, 71, 65, 65, 65, 65, 65, 71, 67, 84,
            65, 65, 84, 67, 84, 67, 84, 84, 71, 71, 65, 67, 65, 65, 71, 65, 65, 65, 67, 67, 65, 65,
            67, 65, 84, 67, 71, 65, 65, 71, 65, 71, 84, 71, 65, 84, 67, 71, 67, 67, 71, 65, 84, 65,
            84, 71, 71, 84, 71, 71, 84, 67, 71, 67, 65, 65, 84, 65, 84, 84, 84, 65, 84, 71, 65, 84,
            67, 84, 65, 65, 67, 65, 65, 65, 71, 67, 84, 65, 71, 84, 84, 71, 65, 67, 84, 65, 67, 67,
            84, 65, 71, 65, 84, 65, 67, 65, 65, 84, 71, 71, 71, 84, 67, 67, 65, 84, 67, 65, 71, 84,
            65, 71, 67, 84, 71, 65, 65, 67, 65, 65, 71, 84, 84, 65, 65, 71, 65, 65, 65, 67, 67, 65,
            67, 71, 67, 67, 65, 84, 65, 65, 65, 65, 65, 65, 67, 67, 71, 71, 84, 65, 84, 65, 84, 65,
            67, 67, 71, 84, 65, 65, 71, 65, 65, 65, 65, 65, 67, 71, 65, 67, 65, 71, 67, 84, 84, 65,
            65, 65, 65, 65, 65, 71, 67, 65, 67, 65, 65, 84, 71, 71, 65, 65, 67, 84, 71, 65, 71, 67,
            71, 67, 71, 65, 71, 67, 71, 65, 84, 71, 67, 65, 67, 71, 65, 84, 65, 71, 67, 65, 65, 65,
            65, 67, 71,
        ];
        let start_self = 532;
        let end_self = 575;

        let encode_self = Encoder::new(&self_read[start_self..end_self]).collect_vec();

        let revcomp_other = RevCompIter::new(&read, start, end).collect_vec();
        assert_eq!(encode_self[0], revcomp_other[0]); // 32 bases: OK
                                                      // assert_eq!(encode_self[1], revcomp_other[1]); // 64 bases: OK
                                                      // assert_eq!(encode_self[2], revcomp_other[2]); // 96 bases: OK

        let size_prefix =
            common_prefix_length_fr(&self_read[start_self..end_self], &read, start, end);
        assert_eq!(size_prefix, 43);
    }

    #[test]
    fn test_encode_32_bases_revcomp() {
        {
            let read = String::from("TATTTACTGTAATGAAGGACCTTCGTCTCCCC");
            let read = read.as_bytes();

            let encoded = encode_32_bases_revcomp(read.try_into().unwrap());
            assert_eq!(
                encoded,
                // G G G G  A G A C  G A A G  G T C C  T T C A  T T A C  A G T A  A A T A
                0b11111111_00110001_11000011_11100101_10100100_10100001_00111000_00001000
            )
        }

        {
            let read = String::from("AAAAAAGGACCTTCGTCTCCCCGGGGAGACGA");
            let read = read.as_bytes();

            let encoded = encode_32_bases_revcomp(read.try_into().unwrap());
            assert_eq!(
                encoded,
                // T C G T  C T C C  C C G G  G G A G  A C G A  A G G T  C C T T  T T T T
                0b10011110_01100101_01011111_11110011_00011100_00111110_01011010_10101010
            )
        }
    }

    #[test]
    fn test_encode_32_bases_revcomp_slow() {
        let read = String::from("TACTGTAATGAAGGACCTTCGTCTCCCC");
        let read = read.as_bytes();

        let encoded = encode_up_to_32_bases_revcomp_slow(read);
        assert_eq!(
            encoded,
            // G G G G  A G A C  G A A G  G T C C  T T C A  T T A C  A G T A
            0b11111111_00110001_11000011_11100101_10100100_10100001_00111000_00000000
        )
    }

    #[test]
    fn test_encode_32_bases_revcomp_slow_unique_letter() {
        let read = String::from("C");
        let read = read.as_bytes();

        let encoded = encode_up_to_32_bases_revcomp_slow(read);
        assert_eq!(
            encoded,
            0b1100000000000000000000000000000000000000000000000000000000000000
        )
    }

    #[test]
    fn test_encode_32_bases_revcomp_slow_3_bases() {
        let read = String::from("CAG");
        let read = read.as_bytes();

        let encoded = encode_up_to_32_bases_revcomp_slow(read);
        assert_eq!(
            encoded,
            0b0110110000000000000000000000000000000000000000000000000000000000
        )
    }

    #[test]
    fn test_encode_32_bases_revcomp_slow_7_bases() {
        let read = String::from("GTTCCAT");
        let read = read.as_bytes();

        let encoded = encode_up_to_32_bases_revcomp_slow(read);
        assert_eq!(
            encoded,
            0b0010111100000100000000000000000000000000000000000000000000000000
        )
    }
}
